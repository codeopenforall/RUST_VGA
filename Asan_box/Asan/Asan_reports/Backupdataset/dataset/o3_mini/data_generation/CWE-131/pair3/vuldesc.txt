The vulnerability stems from incorrect calculation of the buffer size. Instead of using the actual length of the input string, the code mistakenly uses mem::size_of::<&str>(), which returns the size of a string reference (a fixed constant depending on the architecture). When a longer string is passed, the unsafe memory copy writes beyond the allocated buffer, leading to potential buffer overflow.