The vulnerable codeâ€™s update function uses an incorrect boundary check (using "index <= self.data.len()" instead of "index < self.data.len()"). This mistake permits an index equal to the vector's length, causing unsafe pointer arithmetic to write beyond the allocated memory. The issue is compounded by concurrent updates, mirroring real-world unsafe memory handling scenarios as seen in certain RustSec reports.