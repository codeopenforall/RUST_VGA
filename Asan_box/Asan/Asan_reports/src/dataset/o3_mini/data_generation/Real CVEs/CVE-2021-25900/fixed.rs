#![no_std]
extern crate alloc;

use alloc::vec::Vec;
use core::ptr;

// Minimal “A” to match A::Item in the original smallvec code
pub trait Array {
    type Item;
}

pub struct A8;
impl Array for A8 {
    type Item = u8;
}

// Minimal SmallVec-like container providing required APIs
pub struct SmallVec<A: Array> {
    buf: Vec<A::Item>,
}

impl<A: Array> SmallVec<A> {
    pub fn new() -> Self {
        Self { buf: Vec::new() }
    }

    #[inline] pub fn len(&self) -> usize { self.buf.len() }
    #[inline] pub fn reserve(&mut self, n: usize) { self.buf.reserve(n) }
    #[inline] pub unsafe fn set_len(&mut self, n: usize) { self.buf.set_len(n) }
    #[inline] pub fn extend<I: IntoIterator<Item = A::Item>>(&mut self, it: I) { self.buf.extend(it) }
    #[inline] pub fn insert(&mut self, idx: usize, x: A::Item) { self.buf.insert(idx, x) }
    #[inline] pub fn as_mut_ptr(&mut self) -> *mut A::Item { self.buf.as_mut_ptr() }

    // ----------------------
    // CVE-2021-25900 FIXED
    // ----------------------
    pub fn insert_many<I: IntoIterator<Item = A::Item>>(&mut self, index: usize, iterable: I) {
        let mut iter = iterable.into_iter();

        if index == self.len() {
            return self.extend(iter);
        }

        let (lower_size_bound, _upper_size_bound) = iter.size_hint();
        assert!(lower_size_bound <= isize::MAX as usize); // Ensure offset is indexable
        assert!(index + lower_size_bound >= index);       // Protect against overflow
        self.reserve(lower_size_bound);

        let mut num_added = 0;

        unsafe {
            let old_len = self.len();
            assert!(index <= old_len);

            let ptr0 = self.as_mut_ptr().offset(index as isize);

            // Move the trailing elements.
            ptr::copy(ptr0, ptr0.offset(lower_size_bound as isize), old_len - index);

            // In case the iterator panics, don't double-drop the items we just copied above.
            self.set_len(index);

            while num_added < lower_size_bound {
                let element = match iter.next() {
                    Some(x) => x,
                    None => break,
                };

                let cur = ptr0.offset(num_added as isize);
                ptr::write(cur, element);
                num_added += 1;
            }

            if num_added < lower_size_bound {
                // Iterator provided fewer elements than the hint
                ptr::copy(
                    ptr0.offset(lower_size_bound as isize),
                    ptr0.offset(num_added as isize),
                    old_len - index,
                );
            }

            self.set_len(old_len + num_added);
        }

        // If the iterator has more than `lower_size_bound` elements,
        // insert the rest one-by-one.
        for element in iter {
            self.insert(index + num_added, element);
            num_added += 1;
        }
    }
}

