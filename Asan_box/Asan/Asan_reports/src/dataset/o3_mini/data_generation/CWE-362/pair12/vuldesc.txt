The vulnerable code exposes a race condition by using an unsynchronized global mutable variable. The update for the counter is performed in a non-atomic read–modify–write cycle within an unsafe block. In a multithreaded environment, this can lead to missed increments when threads are preempted after reading the value and before writing it back. The use of thread::yield_now further increases the window for race conditions.