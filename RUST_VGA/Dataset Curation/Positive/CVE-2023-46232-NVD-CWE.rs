pub fn build_vyper(
    source_code: &str,
    version: semver::Version,
    message_version: &str,
) -> anyhow::Result<()> {
    check_dependencies();

    let vyper = VyperCompiler::new(VyperCompiler::DEFAULT_EXECUTABLE_NAME.to_owned());
    if vyper.version.default != version {
        panic!("{}", message_version);
    }

    inkwell::support::enable_llvm_pretty_stack_trace();
    compiler_llvm_context::initialize_target();
    let _ = crate::process::EXECUTABLE.set(PathBuf::from(crate::r#const::DEFAULT_EXECUTABLE_NAME));
    let optimizer_settings = compiler_llvm_context::OptimizerSettings::none();

    let mut sources = BTreeMap::new();
    sources.insert("test.vy".to_string(), source_code.to_string());
    let input = VyperStandardJsonInput::try_from_sources(
        sources.clone(),
        VyperStandardJsonInputSettingsEVMVersion::Paris,
        VyperStandardJsonInputSettingsSelection::generate_default(),
        true,
    )?;

    let output = vyper.standard_json(input)?;

    let project = output.try_into_project(&vyper.version.default)?;
    let _build = project.compile(
        optimizer_settings,
        false,
        zkevm_assembly::RunningVmEncodingMode::Production,
        None,
    )?;

    Ok(())
}

pub fn compile(
        self,
        optimizer_settings: compiler_llvm_context::OptimizerSettings,
        include_metadata_hash: bool,
        bytecode_encoding: zkevm_assembly::RunningVmEncodingMode,
        debug_config: Option<compiler_llvm_context::DebugConfig>,
    ) -> anyhow::Result<Build> {
        let mut build = Build::default();
        let source_code_hash = if include_metadata_hash {
            Some(self.source_code_hash)
        } else {
            None
        };
        let results: BTreeMap<String, anyhow::Result<ContractBuild>> = self
            .contracts
            .into_par_iter()
            .map(|(full_path, contract)| {
                let process_output = crate::process::call(ProcessInput::new(
                    full_path.clone(),
                    contract,
                    source_code_hash,
                    bytecode_encoding == zkevm_assembly::RunningVmEncodingMode::Testing,
                    optimizer_settings.clone(),
                    debug_config.clone(),
                ));

                (full_path, process_output.map(|output| output.build))
            })
            .collect();

        let is_forwarder_used = results.iter().any(|(_path, result)| {
            result
                .as_ref()
                .map(|contract| {
                    contract
                        .build
                        .factory_dependencies
                        .contains_key(crate::r#const::FORWARDER_CONTRACT_HASH.as_str())
                })
                .unwrap_or_default()
        });
        if is_forwarder_used {
            let forwarder_build = compiler_llvm_context::Build::new(
                crate::r#const::FORWARDER_CONTRACT_ASSEMBLY.to_owned(),
                None,
                crate::r#const::FORWARDER_CONTRACT_BYTECODE.clone(),
                crate::r#const::FORWARDER_CONTRACT_HASH.clone(),
            );
            build.contracts.insert(
                crate::r#const::FORWARDER_CONTRACT_NAME.to_owned(),
                ContractBuild::new(forwarder_build),
            );
        }

        for (path, result) in results.into_iter() {
            match result {
                Ok(contract) => {
                    build.contracts.insert(path, contract);
                }
                Err(error) => {
                    anyhow::bail!("Contract `{}` compiling error: {:?}", path, error);
                }
            }
        }

        Ok(build)
    }

fn declare(&mut self, context: &mut compiler_llvm_context::Context<D>) -> anyhow::Result<()> {
        let mut entry = compiler_llvm_context::EntryFunction::default();
        entry.declare(context)?;

        let mut runtime =
            compiler_llvm_context::Runtime::new(compiler_llvm_context::AddressSpace::HeapAuxiliary);
        runtime.declare(context)?;

        compiler_llvm_context::DeployCodeFunction::new(
            compiler_llvm_context::DummyLLVMWritable::default(),
        )
        .declare(context)?;
        compiler_llvm_context::RuntimeCodeFunction::new(
            compiler_llvm_context::DummyLLVMWritable::default(),
        )
        .declare(context)?;

        for name in [
            compiler_llvm_context::Runtime::FUNCTION_DEPLOY_CODE,
            compiler_llvm_context::Runtime::FUNCTION_RUNTIME_CODE,
            compiler_llvm_context::Runtime::FUNCTION_ENTRY,
        ]
        .into_iter()
        {
            context
                .get_function(name)
                .expect("Always exists")
                .borrow_mut()
                .set_vyper_data(compiler_llvm_context::FunctionVyperData::default());
        }

        entry.into_llvm(context)?;

        runtime.into_llvm(context)?;

        Ok(())
    }

fn into_llvm(mut self, context: &mut compiler_llvm_context::Context<D>) -> anyhow::Result<()> {
        let (mut runtime_code, immutables_size) =
            self.expression.extract_runtime_code()?.unwrap_or_default();
        let mut deploy_code = self.expression.try_into_deploy_code()?;

        match immutables_size {
            Expression::IntegerLiteral(number) => {
                let immutables_size = number
                    .as_u64()
                    .ok_or_else(|| anyhow::anyhow!("Immutable size `{}` parsing error", number))?;
                let vyper_data =
                    compiler_llvm_context::ContextVyperData::new(immutables_size as usize, false);
                context.set_vyper_data(vyper_data);
            }
            expression => anyhow::bail!("Invalid immutables size format: {:?}", expression),
        }

        let mut function_expressions = deploy_code
            .extract_functions()?
            .into_iter()
            .map(|(label, expression)| (label, expression, compiler_llvm_context::CodeType::Deploy))
            .collect::<Vec<(String, Expression, compiler_llvm_context::CodeType)>>();
        function_expressions.extend(
            runtime_code
                .extract_functions()?
                .into_iter()
                .map(|(label, expression)| {
                    (label, expression, compiler_llvm_context::CodeType::Runtime)
                })
                .collect::<Vec<(String, Expression, compiler_llvm_context::CodeType)>>(),
        );

        let mut functions = Vec::with_capacity(function_expressions.capacity());
        for (label, expression, code_type) in function_expressions.into_iter() {
            let mut metadata_label = label
                .strip_suffix(format!("_{}", compiler_llvm_context::CodeType::Deploy).as_str())
                .unwrap_or(label.as_str());
            metadata_label = label
                .strip_suffix(format!("_{}", compiler_llvm_context::CodeType::Runtime).as_str())
                .unwrap_or(metadata_label);
            metadata_label = label
                .strip_suffix(format!("_{}", crate::r#const::LABEL_SUFFIX_COMMON).as_str())
                .unwrap_or(metadata_label);

            let metadata_name =
                self.source_metadata
                    .function_info
                    .iter()
                    .find_map(|(name, function)| {
                        if metadata_label == function.ir_identifier.as_str() {
                            Some(name.to_owned())
                        } else {
                            None
                        }
                    });
            let metadata = match metadata_name {
                Some(metadata_name) => self
                    .source_metadata
                    .function_info
                    .get(metadata_name.as_str())
                    .cloned(),
                None => None,
            };
            functions.push((Function::new(label, metadata, expression), code_type));
        }
        for (function, _code_type) in functions.iter_mut() {
            function.declare(context)?;
        }
        for (function, code_type) in functions.into_iter() {
            context.set_code_type(code_type);
            function.into_llvm(context)?;
        }

        compiler_llvm_context::DeployCodeFunction::new(deploy_code).into_llvm(context)?;
        compiler_llvm_context::RuntimeCodeFunction::new(runtime_code).into_llvm(context)?;

        Ok(())
    }

pub fn into_llvm_value<D>(
        self,
        context: &mut compiler_llvm_context::Context<D>,
    ) -> anyhow::Result<()>
    where
        D: compiler_llvm_context::Dependency + Clone,
    {
        let [identifier, value] = self.0;
        let identifier = identifier.try_into_identifier()?;

        let pointer = context
            .current_function()
            .borrow()
            .get_stack_pointer(identifier.as_str())
            .ok_or_else(|| anyhow::anyhow!("Variable `{}` not found", identifier))?;

        let value = value
            .into_llvm_value(context)?
            .ok_or_else(|| anyhow::anyhow!("Expected a value"))?;
        context.build_store(pointer, value);

        Ok(())
    }

fn main_inner() -> anyhow::Result<()> {
    let mut arguments = Arguments::new();
    arguments.validate()?;

    rayon::ThreadPoolBuilder::new()
        .stack_size(RAYON_WORKER_STACK_SIZE)
        .build_global()
        .expect("Thread pool configuration failure");
    inkwell::support::enable_llvm_pretty_stack_trace();
    compiler_llvm_context::initialize_target();

    if arguments.version {
        println!(
            "{} v{} (LLVM build {})",
            env!("CARGO_PKG_DESCRIPTION"),
            env!("CARGO_PKG_VERSION"),
            inkwell::support::get_commit_id().to_string(),
        );
        return Ok(());
    }

    if arguments.recursive_process {
        return compiler_vyper::run_process();
    }

    let debug_config = match arguments.debug_output_directory {
        Some(debug_output_directory) => {
            std::fs::create_dir_all(debug_output_directory.as_path())?;
            Some(compiler_llvm_context::DebugConfig::new(
                debug_output_directory,
            ))
        }
        None => None,
    };

    for path in arguments.input_files.iter_mut() {
        *path = path.canonicalize()?;
    }

    let vyper = compiler_vyper::VyperCompiler::new(
        arguments
            .vyper
            .unwrap_or_else(|| compiler_vyper::VyperCompiler::DEFAULT_EXECUTABLE_NAME.to_owned()),
    );

    let mut optimizer_settings = match arguments.optimization {
        Some(mode) => compiler_llvm_context::OptimizerSettings::try_from_cli(mode)?,
        None => compiler_llvm_context::OptimizerSettings::cycles(),
    };
    optimizer_settings.is_verify_each_enabled = arguments.llvm_verify_each;
    optimizer_settings.is_debug_logging_enabled = arguments.llvm_debug_logging;

    let include_metadata_hash = match arguments.metadata_hash {
        Some(metadata_hash) => {
            let metadata = compiler_llvm_context::MetadataHash::from_str(metadata_hash.as_str())?;
            metadata != compiler_llvm_context::MetadataHash::None
        }
        None => true,
    };

    let build = if arguments.llvm_ir {
        compiler_vyper::llvm_ir(
            arguments.input_files,
            optimizer_settings,
            include_metadata_hash,
            debug_config,
        )
    } else if arguments.zkasm {
        compiler_vyper::zkasm(arguments.input_files, include_metadata_hash, debug_config)
    } else {
        match arguments.format.as_deref() {
            Some("combined_json") => {
                compiler_vyper::combined_json(
                    arguments.input_files,
                    &vyper,
                    !arguments.disable_vyper_optimizer,
                    optimizer_settings,
                    include_metadata_hash,
                    debug_config,
                    arguments.output_directory,
                    arguments.overwrite,
                )?;
                return Ok(());
            }
            Some(format) if format.split(',').any(|format| format == "combined_json") => {
                anyhow::bail!("If using combined_json it must be the only output format requested");
            }
            Some(_) | None => compiler_vyper::standard_output(
                arguments.input_files,
                &vyper,
                !arguments.disable_vyper_optimizer,
                optimizer_settings,
                include_metadata_hash,
                debug_config,
            ),
        }
    }?;

    match arguments.output_directory {
        Some(output_directory) => {
            std::fs::create_dir_all(output_directory.as_path())?;

            build.write_to_directory(output_directory.as_path(), arguments.overwrite)?;
        }
        None => {
            for (path, contract) in build.contracts.into_iter() {
                eprintln!("Contract `{path}`:");
                let bytecode_string = hex::encode(contract.build.bytecode);
                println!("0x{bytecode_string}");

                if let Some(format) = arguments.format.as_deref() {
                    let extra_output = vyper.extra_output(PathBuf::from(path).as_path(), format)?;
                    println!();
                    println!("{extra_output}");
                }
            }
        }
    }

    Ok(())
}

pub fn new(build: compiler_llvm_context::Build) -> Self {
        Self { build }
    }

pub fn try_from_llvm_ir_path(path: &Path) -> anyhow::Result<Self> {
        let source_code = std::fs::read_to_string(path)
            .map_err(|error| anyhow::anyhow!("LLVM IR file {:?} reading error: {}", path, error))?;
        let path = path.to_string_lossy().to_string();

        let source_code_hash = sha3::Keccak256::digest(source_code.as_bytes()).into();

        let mut project_contracts = BTreeMap::new();
        project_contracts.insert(
            path,
            LLVMIRContract::new(compiler_llvm_context::LLVM_VERSION, source_code).into(),
        );

        Ok(Self::new(
            compiler_llvm_context::LLVM_VERSION,
            source_code_hash,
            project_contracts,
        ))
    }

pub fn try_from_zkasm_path(path: &Path) -> anyhow::Result<Self> {
        let source_code = std::fs::read_to_string(path).map_err(|error| {
            anyhow::anyhow!("zkEVM assembly file {:?} reading error: {}", path, error)
        })?;
        let path = path.to_string_lossy().to_string();

        let source_code_hash = sha3::Keccak256::digest(source_code.as_bytes()).into();

        let mut project_contracts = BTreeMap::new();
        project_contracts.insert(
            path,
            ZKASMContract::new(compiler_llvm_context::ZKEVM_VERSION, source_code).into(),
        );

        Ok(Self::new(
            compiler_llvm_context::ZKEVM_VERSION,
            source_code_hash,
            project_contracts,
        ))
    }

pub fn write_to_directory(
        self,
        output_directory: &Path,
        contract_path: &Path,
        overwrite: bool,
    ) -> anyhow::Result<()> {
        let contract_name = Self::short_path(contract_path.to_str().expect("Always valid"));

        let assembly_file_name = format!(
            "{}.{}",
            contract_name,
            compiler_common::EXTENSION_ZKEVM_ASSEMBLY
        );
        let mut assembly_file_path = output_directory.to_owned();
        assembly_file_path.push(assembly_file_name);

        if assembly_file_path.exists() && !overwrite {
            eprintln!(
                "Refusing to overwrite an existing file {assembly_file_path:?} (use --overwrite to force).",
            );
        } else {
            File::create(&assembly_file_path)
                .map_err(|error| {
                    anyhow::anyhow!("File {:?} creating error: {}", assembly_file_path, error)
                })?
                .write_all(self.build.assembly_text.as_bytes())
                .map_err(|error| {
                    anyhow::anyhow!("File {:?} writing error: {}", assembly_file_path, error)
                })?;
        }

        let binary_file_name = format!(
            "{}.{}",
            contract_name,
            compiler_common::EXTENSION_ZKEVM_BINARY
        );
        let mut binary_file_path = output_directory.to_owned();
        binary_file_path.push(binary_file_name);

        if binary_file_path.exists() && !overwrite {
            eprintln!(
                "Refusing to overwrite an existing file {binary_file_path:?} (use --overwrite to force).",
            );
        } else {
            File::create(&binary_file_path)
                .map_err(|error| {
                    anyhow::anyhow!("File {:?} creating error: {}", binary_file_path, error)
                })?
                .write_all(self.build.bytecode.as_slice())
                .map_err(|error| {
                    anyhow::anyhow!("File {:?} writing error: {}", binary_file_path, error)
                })?;
        }

        Ok(())
    }

