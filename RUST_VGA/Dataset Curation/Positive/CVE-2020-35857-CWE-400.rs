fn inner_lookup_wildcard(
        &self,
        name: &LowerName,
        record_type: RecordType,
        and_rrsigs: bool,
        supported_algorithms: SupportedAlgorithms,
    ) -> Option<Arc<RecordSet>> {
        let wildcard = if name.is_wildcard() {
            return None;
        } else {
            name.clone().into_wildcard()
        };

        self.inner_lookup(&wildcard, record_type, and_rrsigs, supported_algorithms)
            // we need to change the name to the query name in the result set since this was a wildcard
            .map(|rrset| {
                let mut new_answer =
                    RecordSet::new(name.borrow(), rrset.record_type(), rrset.ttl());

                let (records, _rrsigs): (Vec<&Record>, Vec<&Record>) = rrset
                    .records(and_rrsigs, supported_algorithms)
                    .partition(|r| r.record_type() != RecordType::DNSSEC(DNSSECRecordType::RRSIG));

                for record in records {
                    new_answer.add_rdata(record.rdata().clone());
                }

                #[cfg(feature = "dnssec")]
                for rrsig in _rrsigs {
                    new_answer.insert_rrsig(rrsig.clone())
                }

                Arc::new(new_answer)
            })
    }

pub fn try_from_config(
        origin: Name,
        zone_type: ZoneType,
        allow_axfr: bool,
        root_dir: Option<&Path>,
        config: &FileConfig,
    ) -> Result<Self, String> {
        use std::fs::File;
        use std::io::Read;
        use trust_dns_client::serialize::txt::{Lexer, Parser};

        let zone_path = root_dir
            .map(PathBuf::from)
            .unwrap_or_else(PathBuf::new)
            .join(&config.zone_file_path);

        info!("loading zone file: {:?}", zone_path);

        let mut file = File::open(&zone_path)
            .map_err(|e| format!("error opening {}: {:?}", zone_path.display(), e))?;

        let mut buf = String::new();

        // TODO: this should really use something to read line by line or some other method to
        //  keep the usage down. and be a custom lexer...
        file.read_to_string(&mut buf)
            .map_err(|e| format!("failed to read {}: {:?}", zone_path.display(), e))?;
        let lexer = Lexer::new(&buf);
        let (origin, records) = Parser::new()
            .parse(lexer, Some(origin))
            .map_err(|e| format!("failed to parse {}: {:?}", zone_path.display(), e))?;

        info!(
            "zone file loaded: {} with {} records",
            origin,
            records.len()
        );

        FileAuthority::new(origin, records, zone_type, allow_axfr)
    }

