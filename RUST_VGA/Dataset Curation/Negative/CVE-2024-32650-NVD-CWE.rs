  pub(crate) fn process_alert(&mut self, alert: &AlertMessagePayload) -> Result<(), Error> {

        // Reject unknown AlertLevels.

        if let AlertLevel::Unknown(_) = alert.level {

            return Err(self.send_fatal_alert(

                AlertDescription::IllegalParameter,

                Error::AlertReceived(alert.description),

            ));

        }



        // If we get a CloseNotify, make a note to declare EOF to our

        // caller.  But do not treat unauthenticated alerts like this.

        if self.may_receive_application_data && alert.description == AlertDescription::CloseNotify {

            self.has_received_close_notify = true;

            return Ok(());

        }



        // Warnings are nonfatal for TLS1.2, but outlawed in TLS1.3

        // (except, for no good reason, user_cancelled).

        let err = Error::AlertReceived(alert.description);

        if alert.level == AlertLevel::Warning {

            if self.is_tls13() && alert.description != AlertDescription::UserCanceled {

                return Err(self.send_fatal_alert(AlertDescription::DecodeError, err));

            } else {

                warn!("TLS alert warning received: {:?}", alert);

                return Ok(());

            }

        }



        Err(err)

    }

