async fn api_return_to_sso_get_common(
        &self,
        req: &Request,
        session: &Session,
        services: Data<&Services>,
        code: &Option<String>,
    ) -> poem::Result<Result<String, String>> {
        let Some(context) = session.get::<SsoContext>(SSO_CONTEXT_SESSION_KEY) else {
            return Ok(Err("Not in an active SSO process".to_string()));
        };

        let Some(ref code) = *code else {
            return Ok(Err("No authorization code in the return URL request".to_string()));
        };

        let response = context
            .request
            .verify_code((*code).clone())
            .await
            .map_err(poem::error::InternalServerError)?;

        if !response.email_verified.unwrap_or(true) {
            return Ok(Err("The SSO account's e-mail is not verified".to_string()));
        }

        let Some(email) = response.email else {
            return Ok(Err("No e-mail information in the SSO response".to_string()));
        };

        info!("SSO login as {email}");

        let cred = AuthCredential::Sso {
            provider: context.provider,
            email: email.clone(),
        };

        let username = services
            .config_provider
            .lock()
            .await
            .username_for_sso_credential(&cred)
            .await?;
        let Some(username) = username else {
            return Ok(Err(format!("No user matching {email}")));
        };

        let mut auth_state_store = services.auth_state_store.lock().await;
        let state_arc =
            get_auth_state_for_request(&username, session, &mut auth_state_store).await?;

        let mut state = state_arc.lock().await;
        let mut cp = services.config_provider.lock().await;

        if state.username() != username {
            return Ok(Err(format!(
                "Incorrect account for SSO authentication ({username})"
            )));
        }

        if cp.validate_credential(&username, &cred).await? {
            state.add_valid_credential(cred);
        }

        if let AuthResult::Accepted { username } = state.verify() {
            auth_state_store.complete(state.id()).await;
            authorize_session(req, username).await?;
        }

        Ok(Ok(context
            .next_url
            .as_deref()
            .unwrap_or("/@warpgate#/login")
            .to_owned()))
    }

