The vulnerability arises from improper verification of a cryptographic signature. The check function unsafely casts the signature byte slice to a fixed-size array assuming it contains 64 bytes without verifying its length. This misuse of unsafe code bypasses proper signature length and algorithm validation, leading to potential acceptance of invalid or malicious data. Such flaws have been documented in real-world cases where skipping context or domain separation in cryptographic APIs allowed attackers to forge authentic messages.